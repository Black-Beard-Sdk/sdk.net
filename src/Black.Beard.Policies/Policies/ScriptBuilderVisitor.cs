using Antlr4.Runtime;
using Antlr4.Runtime.Atn;
using Antlr4.Runtime.Misc;
using Antlr4.Runtime.Tree;
using Bb.Analysis.DiagTraces;
using Bb.Policies.Asts;
using Bb.Policies.Parser;
using System.Globalization;
using System.Text;

#pragma warning disable CS3001
#pragma warning disable CS3003

namespace Bb.Policies
{


    /// <summary>
    /// Generate tree of script from a Policy script text
    /// </summary>
    /// <remarks>
    /// ScriptBuilderVisitor implements the visitor pattern to traverse the parse tree 
    /// generated by ANTLR and build a policy AST from it.
    /// </remarks>
    public class ScriptBuilderVisitor : PolicyParserBaseVisitor<object>
    {

        /// <summary>
        /// Initializes static members of the <see cref="ScriptBuilderVisitor"/> class.
        /// </summary>
        /// <remarks>
        /// This static constructor initializes any shared resources or configurations needed by all instances
        /// of the ScriptBuilderVisitor class.
        /// </remarks>
        static ScriptBuilderVisitor()
        {

        }

        /// <summary>
        /// Create a new instance of <see cref="ScriptBuilderVisitor"/> with a container and rule action.
        /// </summary>
        /// <param name="parser">The policy parser that generated the parse tree. Must not be null.</param>
        /// <param name="diagnostics">Container for diagnostic messages generated during parsing. Must not be null.</param>
        /// <param name="container">The container to which parsed policies will be added. Can be null.</param>
        /// <param name="action">Action to execute on each parsed policy rule. Can be null.</param>
        /// <param name="path">The file path of the policy script being parsed. Can be null or empty.</param>
        /// <remarks>
        /// This constructor creates a visitor that will add parsed policies to the specified container
        /// and execute the specified action on each policy rule. It delegates to the basic constructor
        /// for initialization of parser, diagnostics, and path.
        /// </remarks>
        /// <exception cref="System.ArgumentNullException">Thrown when parser or diagnostics is null.</exception>
        /// <example>
        /// <code lang="C#">
        /// var lexer = new PolicyLexer(new AntlrInputStream(policyText));
        /// var tokenStream = new CommonTokenStream(lexer);
        /// var parser = new PolicyParser(tokenStream);
        /// var diagnostics = new ScriptDiagnostics();
        /// var container = new PolicyContainer();
        /// 
        /// var visitor = new ScriptBuilderVisitor(parser, diagnostics, container, 
        ///     rule => Console.WriteLine($"Parsed rule: {rule.Name}"), 
        ///     "policy.txt");
        /// 
        /// var result = visitor.Visit(parser.script());
        /// </code>
        /// </example>
        public ScriptBuilderVisitor(PolicyParser parser, ScriptDiagnostics diagnostics, PolicyContainer container, Action<PolicyRule> action, string path)
            : this(parser, diagnostics, path)
        {
            _container = container;
            _action = action;
        }


        /// <summary>
        /// Create a new instance of <see cref="ScriptBuilderVisitor"/> with basic parameters.
        /// </summary>
        /// <param name="parser">The policy parser that generated the parse tree. Must not be null.</param>
        /// <param name="diagnostics">Container for diagnostic messages generated during parsing. Must not be null.</param>
        /// <param name="path">The file path of the policy script being parsed. Can be null or empty.</param>
        /// <remarks>
        /// This constructor initializes the visitor with the specified parser, diagnostics container,
        /// and script path. It sets the culture to InvariantCulture and resolves the script directory path.
        /// </remarks>
        /// <exception cref="System.ArgumentNullException">Thrown when parser or diagnostics is null.</exception>
        /// <example>
        /// <code lang="C#">
        /// var lexer = new PolicyLexer(new AntlrInputStream(policyText));
        /// var tokenStream = new CommonTokenStream(lexer);
        /// var parser = new PolicyParser(tokenStream);
        /// var diagnostics = new ScriptDiagnostics();
        /// 
        /// var visitor = new ScriptBuilderVisitor(parser, diagnostics, "policy.txt");
        /// var result = visitor.Visit(parser.script());
        /// </code>
        /// </example>
        public ScriptBuilderVisitor(PolicyParser parser, ScriptDiagnostics diagnostics, string path)
        {

            _currentCulture = CultureInfo.InvariantCulture;
            _parser = parser;
            _diagnostics = diagnostics;
            _scriptPath = path;
            _stack = new Stack<BuildContext>();

            if (!string.IsNullOrEmpty(path))
            {
                var dir = new FileInfo(path).Directory;
                if (dir != null)
                    ScriptPathDirectory = dir.FullName;
            }

            if (string.IsNullOrEmpty(ScriptPathDirectory))
                ScriptPathDirectory = AppDomain.CurrentDomain.BaseDirectory;

        }

        /// <summary>
        /// Parse tree produced by <see cref="PolicyParser.script"/>.
        /// </summary>
        /// <param name="context">The parse tree context for the script. Must not be null.</param>
        /// <returns>A PolicyContainer containing all parsed policy elements.</returns>
        /// <remarks>
        /// This method visits the script context and builds a complete policy container from all the
        /// policy elements defined in the script. It checks for duplicate names and reports errors.
        /// </remarks>
        /// <exception cref="System.ArgumentNullException">Thrown when context is null.</exception>
        /// <example>
        /// <code lang="C#">
        /// var visitor = new ScriptBuilderVisitor(parser, diagnostics, "policy.txt");
        /// var container = visitor.VisitScript(parser.script());
        /// </code>
        /// </example>
        /// <returns>
        /// A <see cref="PolicyContainer"/> containing all policy elements from the script.
        /// </returns>
        public override object VisitScript([NotNull] PolicyParser.ScriptContext context)
        {

            _initialSource = new StringBuilder(context.Start.InputStream.ToString());

            var pair = context.pair();

            if (_container == null)
                _container = new PolicyContainer() { Diagnostics = _diagnostics };

            foreach (var item in pair)
            {

                var o = (PolicyNamed)item.Accept(this);
                if (o != null)
                {

                    o.Origin = this._scriptPath;

                    if (_action != null && o is PolicyRule r1)
                        _action(r1);

                    if (!_container.Add(o))
                    {

                        string name = o.Name;
                        if (o is PolicyRule r)
                            name = "policy " + r.Name;
                        else if (o is PolicyVariable s)
                            name = "alias " + s.Name;
                        this.AddError(o.Location, name, "duplicated name", _scriptPath);

                    }
                }
            }

            return _container;

        }

        /// <summary>
        /// Visits a category context and extracts the category identifier.
        /// </summary>
        /// <param name="context">The context for a category in the policy script. Must not be null.</param>
        /// <returns>The text of the category identifier, or null if not found.</returns>
        /// <remarks>
        /// This method extracts the text of a category identifier from the parse tree.
        /// Categories are used for grouping and filtering policy rules.
        /// </remarks>
        /// <example>
        /// <code lang="C#">
        /// var categoryContext = parser.category();
        /// var categoryName = (string)visitor.VisitCategory(categoryContext);
        /// </code>
        /// </example>
        /// <returns>
        /// A <see cref="System.String"/> containing the category identifier, or null if not found.
        /// </returns>
        public override object VisitCategory([NotNull] PolicyParser.CategoryContext context)
        {

            var id = context.ID();
            if (id != null)
                return id.GetText();

            return null;
        }

        /// <summary>
        /// Visits a policy identifier context and extracts the policy name.
        /// </summary>
        /// <param name="context">The context for a policy identifier. Must not be null.</param>
        /// <returns>The text of the policy identifier, or null if not found.</returns>
        /// <remarks>
        /// This method extracts the name of a policy rule from the parse tree.
        /// It handles both regular identifiers and quoted identifiers.
        /// </remarks>
        /// <example>
        /// <code lang="C#">
        /// var policyIdContext = parser.policy_id();
        /// var policyName = (string)visitor.VisitPolicy_id(policyIdContext);
        /// </code>
        /// </example>
        /// <returns>
        /// A <see cref="System.String"/> containing the policy identifier, or null if not found.
        /// </returns>
        public override object VisitPolicy_id([NotNull] PolicyParser.Policy_idContext context)
        {

            StringBuilder sb = new StringBuilder();

            var id1 = context.ID();
            if (id1 != null && id1.Length > 0)
                foreach (var item in id1)
                {
                    if (sb.Length > 0)
                        sb.Append(".");
                    sb.Append(item.GetText());
                }

            var id2 = context.IDQUOTED();
            if (id2 != null)
                sb.Append(id2.GetText());

            return sb.ToString();

        }

        /// <summary>
        /// Visits an alias identifier context and extracts the alias name.
        /// </summary>
        /// <param name="context">The context for an alias identifier. Must not be null.</param>
        /// <returns>The text of the alias identifier, or null if not found.</returns>
        /// <remarks>
        /// This method extracts the name of an alias (variable) from the parse tree.
        /// It handles both regular identifiers and quoted identifiers.
        /// </remarks>
        /// <example>
        /// <code lang="C#">
        /// var aliasIdContext = parser.alias_id();
        /// var aliasName = (string)visitor.VisitAlias_id(aliasIdContext);
        /// </code>
        /// </example>
        /// <returns>
        /// A <see cref="System.String"/> containing the alias identifier, or null if not found.
        /// </returns>
        public override object VisitAlias_id([NotNull] PolicyParser.Alias_idContext context)
        {
            var id = context.ID();
            if (id != null)
                return id.GetText();

            id = context.IDQUOTED();
            if (id != null)
                return id.GetText().Trim('\'');

            return null;
        }

        /// <summary>
        /// Visits a string context and extracts the string value.
        /// </summary>
        /// <param name="context">The context for a string in the policy script. Must not be null.</param>
        /// <returns>The string value with quotes removed, or an empty string if not found.</returns>
        /// <remarks>
        /// This method extracts a string literal from the parse tree, removing the surrounding quotes.
        /// </remarks>
        /// <example>
        /// <code lang="C#">
        /// var stringContext = parser.string();
        /// var stringValue = (string)visitor.VisitString(stringContext);
        /// </code>
        /// </example>
        /// <returns>
        /// A <see cref="System.String"/> containing the string value with quotes removed.
        /// </returns>
        public override object VisitString([NotNull] PolicyParser.StringContext context)
        {

            ITerminalNode str = context.STRING();
            if (str != null)
            {
                var txt = str.GetText()?.Trim() ?? string.Empty;
                return txt.Trim('"');
            }

            return string.Empty;

        }

        /// <summary>
        /// Visits a key reference context and creates a policy constant for the key.
        /// </summary>
        /// <param name="context">The context for a key reference. Must not be null.</param>
        /// <returns>A policy constant representing the key.</returns>
        /// <remarks>
        /// This method creates a policy constant from a key reference in the parse tree,
        /// handling both regular identifiers and quoted identifiers.
        /// </remarks>
        /// <exception cref="System.NotImplementedException">Thrown when the context contains an unsupported key reference format.</exception>
        /// <example>
        /// <code lang="C#">
        /// var keyRefContext = parser.key_ref();
        /// var keyConstant = (PolicyConstant)visitor.VisitKey_ref(keyRefContext);
        /// </code>
        /// </example>
        /// <returns>
        /// A <see cref="PolicyConstant"/> representing the key reference.
        /// </returns>
        public override object VisitKey_ref([NotNull] PolicyParser.Key_refContext context)
        {

            var id = context.ID();
            if (id != null)
                return new PolicyConstant(id.GetText(), ConstantType.Id) { Location = context.ToLocation() };

            var id2 = context.IDQUOTED();
            if (id2 != null)
                return new PolicyConstant(id2.GetText().Trim('\''), ConstantType.QuotedId) { Location = context.ToLocation() };

            throw new NotImplementedException(context.GetText());

        }

        /// <summary>
        /// Visits a value reference context and creates a policy constant for the value.
        /// </summary>
        /// <param name="context">The context for a value reference. Must not be null.</param>
        /// <returns>A policy constant representing the value.</returns>
        /// <remarks>
        /// This method creates a policy constant from a value reference in the parse tree,
        /// handling strings, identifiers, quoted identifiers, and boolean values.
        /// </remarks>
        /// <exception cref="System.NotImplementedException">Thrown when the context contains an unsupported value reference format.</exception>
        /// <example>
        /// <code lang="C#">
        /// var valueRefContext = parser.value_ref();
        /// var valueConstant = (PolicyConstant)visitor.VisitValue_ref(valueRefContext);
        /// </code>
        /// </example>
        /// <returns>
        /// A <see cref="PolicyConstant"/> representing the value reference.
        /// </returns>
        public override object VisitValue_ref([NotNull] PolicyParser.Value_refContext context)
        {

            var str = context.@string();
            if (str != null)
                return new PolicyConstant((string)str.Accept(this), ConstantType.String) { Location = context.ToLocation() };

            var id = context.ID();
            if (id != null)
                return new PolicyConstant(id.GetText(), ConstantType.Id) { Location = context.ToLocation() };

            var id2 = context.IDQUOTED();
            if (id2 != null)
                return new PolicyConstant(id2.GetText().Trim('\''), ConstantType.QuotedId) { Location = context.ToLocation() };

            var boolean = context.boolean();
            if (boolean != null)
                return new PolicyConstant(boolean.GetText(), ConstantType.Boolean) { Location = context.ToLocation() };

            var integer = context.integer();
            if (integer != null)
                return new PolicyConstant(integer.GetText(), ConstantType.Integer) { Location = context.ToLocation() };

            throw new NotImplementedException(context.GetText());

        }

        /// <summary>
        /// Visits a source context and extracts the source identifier.
        /// </summary>
        /// <param name="context">The context for a source reference. Must not be null.</param>
        /// <returns>The text of the source identifier, or null if not found.</returns>
        /// <remarks>
        /// This method extracts the identifier of a source reference from the parse tree,
        /// handling both regular identifiers and quoted identifiers.
        /// </remarks>
        /// <example>
        /// <code lang="C#">
        /// var sourceContext = parser.source();
        /// var sourceName = (string)visitor.VisitSource(sourceContext);
        /// </code>
        /// </example>
        /// <returns>
        /// A <see cref="System.String"/> containing the source identifier, or null if not found.
        /// </returns>
        public override object VisitSource([NotNull] PolicyParser.SourceContext context)
        {

            var id = context.ID();
            if (id != null)
                return id.GetText();

            id = context.IDQUOTED();
            if (id != null)
                return id.GetText().Trim('\'');

            return null;

        }

        public override object VisitPair_include([NotNull] PolicyParser.Pair_includeContext context)
        {

            var str = context.@string();
            if (str != null)
            {
                var s = (string)str.Accept(this);
                return new PolicyInclude(s)
                {
                    Location = context.ToLocation()
                };
            }

            return null;
        }

        /// <summary>
        /// Visits an alias definition and creates a policy variable.
        /// </summary>
        /// <param name="context">The context for an alias definition. Must not be null.</param>
        /// <returns>A policy variable representing the alias, or null if the alias_id is not found.</returns>
        /// <remarks>
        /// This method creates a policy variable from an alias definition in the parse tree.
        /// It extracts the alias name and value, and sets the origin to the script path.
        /// </remarks>
        /// <example>
        /// <code lang="C#">
        /// var aliasContext = parser.pair_alias();
        /// var variable = (PolicyVariable)visitor.VisitPair_alias(aliasContext);
        /// </code>
        /// </example>
        /// <returns>
        /// A <see cref="PolicyVariable"/> representing the alias, or null if the alias_id is not found.
        /// </returns>
        public override object VisitPair_alias([NotNull] PolicyParser.Pair_aliasContext context)
        {

            var alias_id = context.alias_id();
            if (alias_id == null)
                return null;

            var _id = (string)context.alias_id().Accept(this);
            var str = context.@string();
            if (str != null)
            {
                var s = (string)str.Accept(this);
                return new PolicyVariable(_id)
                {
                    Origin = _scriptPath,
                    Value = new PolicyConstant(s, ConstantType.String)
                    {
                        Location = str.ToLocation()
                    },
                    Location = context.ToLocation()
                };

            }

            return null;
        }

        /// <summary>
        /// Visits a policy definition and creates a policy rule.
        /// </summary>
        /// <param name="context">The context for a policy definition. Must not be null.</param>
        /// <returns>A policy rule representing the policy, or the result of the base visitor if the structure is invalid.</returns>
        /// <remarks>
        /// This method creates a policy rule from a policy definition in the parse tree.
        /// It extracts the policy name, inheritance information, categories, and the policy expression.
        /// </remarks>
        /// <example>
        /// <code lang="C#">
        /// var policyContext = parser.pair_policy();
        /// var rule = (PolicyRule)visitor.VisitPair_policy(policyContext);
        /// </code>
        /// </example>
        /// <returns>
        /// A <see cref="PolicyRule"/> representing the policy, or the result of the base visitor if the structure is invalid.
        /// </returns>
        public override object VisitPair_policy([NotNull] PolicyParser.Pair_policyContext context)
        {

            var policy_id = context.policy_id();
            if (policy_id == null)
                return null;

            var expr = context.expression();
            if (expr != null)
            {

                PolicyRule result = null;

                using (var ctx = NewContext())
                {

                    var _id = (string)policy_id.Accept(this);
                    var e = (Policy)expr.Accept(this);

                    //switch (e.Kind)
                    //{
                    //    case PolicyKind.Variable:
                    //        break;
                    //    case PolicyKind.Constant:
                    //        break;
                    //    case PolicyKind.Container:
                    //        break;
                    //    case PolicyKind.Rule:
                    //        break;
                    //    case PolicyKind.Operation:
                    //        break;
                    //    case PolicyKind.IdExpression:
                    //        e = new PolicyConvert(e) { Location = e.Location };
                    //        break;
                    //    default:
                    //        break;
                    //}


                    result = new PolicyRule(_id)
                    {
                        Value = e,
                        Location = context.ToLocation(),
                        Origin = _scriptPath
                    };

                    var categories = context.categories();
                    if (categories != null)
                    {
                        var c = (List<string>)categories.Accept(this);
                        result.AddCategories(c);
                    }
                }

                return result;

            }

            return base.VisitPair_policy(context);
        }

        /// <summary>
        /// Visits a boolean operation expression and determines the operator type.
        /// </summary>
        /// <param name="context">The context for a boolean operation. Must not be null.</param>
        /// <returns>The policy operator enum value for the boolean operation.</returns>
        /// <remarks>
        /// This method determines the type of boolean operation (AND or OR) from the parse tree.
        /// </remarks>
        /// <example>
        /// <code lang="C#">
        /// var operationContext = parser.operationBoolean();
        /// var operatorType = (PolicyOperator)visitor.VisitOperationBoolean(operationContext);
        /// </code>
        /// </example>
        /// <returns>
        /// A <see cref="PolicyOperator"/> enum value representing the boolean operation.
        /// </returns>
        public override object VisitOperationBoolean([NotNull] PolicyParser.OperationBooleanContext context)
        {

            if (context.AND() != null)
                return PolicyOperator.AndExclusive;

            if (context.OR() != null)
                return PolicyOperator.OrExclusive;

            throw new NotImplementedException(context.GetText());
        }

        /// <summary>
        /// Visits a contains operation expression and determines the operator type.
        /// </summary>
        /// <param name="context">The context for a contains operation. Must not be null.</param>
        /// <returns>The policy operator enum value for the contains operation.</returns>
        /// <remarks>
        /// This method determines the type of contains operation (IN, NOT IN, HAS, HAS NOT) from the parse tree.
        /// </remarks>
        /// <example>
        /// <code lang="C#">
        /// var operationContext = parser.operationContains();
        /// var operatorType = (PolicyOperator)visitor.VisitOperationContains(operationContext);
        /// </code>
        /// </example>
        /// <returns>
        /// A <see cref="PolicyOperator"/> enum value representing the contains operation.
        /// </returns>
        public override object VisitOperationContains([NotNull] PolicyParser.OperationContainsContext context)
        {

            if (context.IN() != null)
                return PolicyOperator.In;

            if (context.NOT_IN() != null)
                return PolicyOperator.NotIn;

            if (context.HAS() != null)
                return PolicyOperator.Has;

            if (context.HAS_NOT() != null)
                return PolicyOperator.HasNot;

            throw new NotImplementedException(context.GetText());
        }

        /// <summary>
        /// Visits an equality operation expression and determines the operator type.
        /// </summary>
        /// <param name="context">The context for an equality operation. Must not be null.</param>
        /// <returns>The policy operator enum value for the equality operation.</returns>
        /// <remarks>
        /// This method determines the type of equality operation (EQUAL, INEQUAL) from the parse tree.
        /// </remarks>
        /// <example>
        /// <code lang="C#">
        /// var operationContext = parser.operationEqual();
        /// var operatorType = (PolicyOperator)visitor.VisitOperationEqual(operationContext);
        /// </code>
        /// </example>
        /// <returns>
        /// A <see cref="PolicyOperator"/> enum value representing the equality operation.
        /// </returns>
        public override object VisitOperationEqual([NotNull] PolicyParser.OperationEqualContext context)
        {

            if (context.EQUAL() != null)
                return PolicyOperator.Equal;

            if (context.INEQUAL() != null)
                return PolicyOperator.NotEqual;

            if (context.LESSER() != null)
                return PolicyOperator.Lesser;

            if (context.GREATER() != null)
                return PolicyOperator.Greater;

            if (context.LESSER_EQUAL() != null)
                return PolicyOperator.LesserOrEqual;

            if (context.GREATER_EQUAL() != null)
                return PolicyOperator.GreaterOrEqual;

            throw new NotImplementedException(context.GetText());

        }

        /// <summary>
        /// Visits an expression context and creates a policy expression.
        /// </summary>
        /// <param name="context">The context for an expression. Must not be null.</param>
        /// <returns>A policy expression representing the parsed expression.</returns>
        /// <remarks>
        /// This method creates a policy expression from an expression context in the parse tree.
        /// It handles key references, value references, boolean operations, and sub-expressions.
        /// </remarks>
        /// <exception cref="System.NotImplementedException">Thrown when the context contains an unsupported expression format.</exception>
        /// <example>
        /// <code lang="C#">
        /// var expressionContext = parser.expression();
        /// var expression = (PolicyExpression)visitor.VisitExpression(expressionContext);
        /// </code>
        /// </example>
        /// <returns>
        /// A <see cref="PolicyExpression"/> representing the parsed expression.
        /// </returns>
        public override object VisitExpression([NotNull] PolicyParser.ExpressionContext context)
        {

            PolicyOperator _operator = PolicyOperator.Undefined;
            var key_ref = context.key_ref();
            Policy left;
            Policy right;

            this.CurrentCtx().TryGetInStorage<bool>("inOperationBoolean", out bool InOperationBoolean);
            using (var ctx = NewContext())
            {

                ctx.AddInStorage("inOperationBoolean", context.operationBoolean() != null);

                if (key_ref != null)
                {
                    string source = string.Empty;
                    var l = context.source();
                    if (l != null)
                        source = l.ID().GetText();

                    left = (Policy)key_ref.Accept(this);
                    left = new PolicyIdExpression((PolicyConstant)left) { Location = context.ToLocation(), Source = source };

                    var plus = context.PLUS();
                    if (plus != null)
                    {
                        _operator = PolicyOperator.Required;
                        return new PolicyOperationUnary(left, _operator) { Location = context.ToLocation() };
                    }

                    var value_ref = context.value_ref();
                    if (value_ref != null)
                    {
                        var @operator = context.operationEqual();
                        _operator = (PolicyOperator)@operator.Accept(this);
                        right = (Policy)value_ref.Accept(this);
                        return new PolicyOperationBinary(left, _operator, right) { Location = context.ToLocation() };
                    }

                    var oo = context.operationBoolean();
                    if (oo != null)
                    {
                        _operator = (PolicyOperator)context.operationBoolean().Accept(this);
                        return new PolicyOperationUnary(left, _operator) { Location = context.ToLocation() };
                    }

                    if (InOperationBoolean)
                        return new PolicyOperationUnary(left, PolicyOperator.UnaryCompare) { Location = context.ToLocation() };

                    return left;

                }

                var e = context.expression();
                left = (Policy)e[0].Accept(this);

                if (context.PARENT_LEFT() != null)
                    return new PolicySubExpression((PolicyExpression)left) { Location = context.ToLocation() };

                else if (context.NOT() != null)
                {
                    _operator = PolicyOperator.Not;
                    return new PolicyOperationUnary((PolicyExpression)left, _operator) { Location = context.ToLocation() };
                }

                var operaC = context.operationContains();
                if (operaC != null)
                {
                    _operator = (PolicyOperator)operaC.Accept(this);
                    right = (Policy)context.array().Accept(this);
                    return new PolicyOperationBinary(left, _operator, right) { Location = context.ToLocation() };
                }

                var o2 = context.operationBoolean();
                if (o2 != null)
                {
                    _operator = (PolicyOperator)o2.Accept(this);
                    right = (Policy)e[1].Accept(this);
                    return new PolicyOperationBinary(left, _operator, right) { Location = context.ToLocation() };
                }

            }

            throw new NotImplementedException(context.GetText());

        }

        /// <summary>
        /// Visits an array context and creates a policy array.
        /// </summary>
        /// <param name="context">The context for an array. Must not be null.</param>
        /// <returns>A policy array representing the parsed array.</returns>
        /// <remarks>
        /// This method creates a policy array from an array context in the parse tree.
        /// It extracts the values and creates a list of policy constants.
        /// </remarks>
        /// <example>
        /// <code lang="C#">
        /// var arrayContext = parser.array();
        /// var array = (PolicyArray)visitor.VisitArray(arrayContext);
        /// </code>
        /// </example>
        /// <returns>
        /// A <see cref="PolicyArray"/> representing the parsed array.
        /// </returns>
        public override object VisitArray([NotNull] PolicyParser.ArrayContext context)
        {

            var values = context.value_ref();
            if (values == null)
                return null;

            List<PolicyConstant> items = new List<PolicyConstant>(values.Length);
            foreach (var item in values)
            {
                var o = (PolicyConstant)item.Accept(this);
                items.Add(o);
            }

            return new PolicyArray(items) { Location = context.ToLocation() };
        }

        /// <summary>
        /// Visits a categories context and creates a list of category names.
        /// </summary>
        /// <param name="context">The context for categories. Must not be null.</param>
        /// <returns>A list of category names.</returns>
        /// <remarks>
        /// This method creates a list of category names from a categories context in the parse tree.
        /// It extracts the category identifiers and adds them to the list.
        /// </remarks>
        /// <example>
        /// <code lang="C#">
        /// var categoriesContext = parser.categories();
        /// var categories = (List<string>)visitor.VisitCategories(categoriesContext);
        /// </code>
        /// </example>
        /// <returns>
        /// A <see cref="List{String}"/> containing the category names.
        /// </returns>
        public override object VisitCategories([NotNull] PolicyParser.CategoriesContext context)
        {

            var values = context.category();
            if (values == null)
                return null;

            List<string> items = new List<string>(values.Length);
            foreach (var item in values)
            {
                var o = (string)item.Accept(this);
                if (!string.IsNullOrEmpty(o))
                    items.Add(o);
            }

            return items;

        }

        /// <summary>
        /// Evaluates errors in the parse tree and adds them to the diagnostics.
        /// </summary>
        /// <param name="item">The parse tree item to evaluate. Can be null.</param>
        /// <remarks>
        /// This method recursively evaluates errors in the parse tree and adds them to the diagnostics container.
        /// It handles error nodes and parser rule contexts with exceptions.
        /// </remarks>
        /// <example>
        /// <code lang="C#">
        /// var tree = parser.script();
        /// visitor.EvaluateErrors(tree);
        /// </code>
        /// </example>
        public void EvaluateErrors(IParseTree item)
        {

            if (item != null)
            {

                if (item is ErrorNodeImpl e)
                    AddError(e);

                else if (item is ParserRuleContext r)
                {

                    if (r.exception != null)
                    {
                        AddError(r);
                    }

                }

                int c = item.ChildCount;
                for (int i = 0; i < c; i++)
                {
                    IParseTree child = item.GetChild(i);
                    EvaluateErrors(child);
                }

            }

        }

        /// <summary>
        /// Visits the parse tree and evaluates errors.
        /// </summary>
        /// <param name="tree">The parse tree to visit. Must not be null.</param>
        /// <returns>The result of visiting the parse tree.</returns>
        /// <remarks>
        /// This method visits the parse tree, evaluates errors, and then delegates to the base visitor.
        /// </remarks>
        /// <example>
        /// <code lang="C#">
        /// var tree = parser.script();
        /// var result = visitor.Visit(tree);
        /// </code>
        /// </example>
        /// <returns>
        /// The result of visiting the parse tree.
        /// </returns>
        public override object Visit(IParseTree tree)
        {
            EvaluateErrors(tree);
            //if (this._diagnostics.Count > 0)
            //    LocalDebug.Stop();
            var result = base.Visit(tree);

            return result;

        }

        /// <summary>
        /// Gets the diagnostic messages generated during parsing.
        /// </summary>
        /// <remarks>
        /// This property provides access to any error, warning, or informational messages
        /// that were generated during the parsing process.
        /// </remarks>
        /// <example>
        /// <code lang="C#">
        /// var visitor = new ScriptBuilderVisitor(parser, diagnostics, container, null, "policy.txt");
        /// visitor.Visit(parser.script());
        /// 
        /// foreach (var error in visitor.Errors)
        /// {
        ///     Console.WriteLine($"{error.Message} at {error.Location}");
        /// }
        /// </code>
        /// </example>
        /// <returns>
        /// A collection of <see cref="ScriptDiagnostic"/> objects representing the parsing errors.
        /// </returns>
        public IEnumerable<ScriptDiagnostic> Errors { get => _diagnostics; }

        /// <summary>
        /// Gets or sets the filename of the policy script being parsed.
        /// </summary>
        /// <remarks>
        /// This property stores the filename of the current policy script, which is used
        /// for error reporting and diagnostics.
        /// </remarks>
        /// <example>
        /// <code lang="C#">
        /// var visitor = new ScriptBuilderVisitor(parser, diagnostics, container, null, null);
        /// visitor.Filename = "custom_policy.txt";
        /// </code>
        /// </example>
        public string? Filename { get; set; }

        /// <summary>
        /// Gets the culture used for parsing culture-specific values.
        /// </summary>
        /// <remarks>
        /// This property provides access to the culture settings used for parsing
        /// numbers, dates, and other culture-specific values in the policy script.
        /// </remarks>
        /// <example>
        /// <code lang="C#">
        /// var visitor = new ScriptBuilderVisitor(parser, diagnostics, container, null, "policy.txt");
        /// CultureInfo culture = visitor.Culture;
        /// Console.WriteLine($"Parsing using culture: {culture.DisplayName}");
        /// </code>
        /// </example>
        /// <returns>
        /// A <see cref="System.Globalization.CultureInfo"/> object representing the current culture.
        /// </returns>
        public CultureInfo Culture { get => _currentCulture; }


        /// <summary>
        /// Adds an error to the diagnostics container.
        /// </summary>
        /// <param name="start">The location of the error. Can be null.</param>
        /// <param name="txt">The text associated with the error. Must not be null.</param>
        /// <param name="message">The error message. Must not be null.</param>
        /// <param name="path">The file path of the script. Can be null or empty.</param>
        /// <remarks>
        /// This method adds an error to the diagnostics container with the specified location, text, message, and path.
        /// </remarks>
        /// <example>
        /// <code lang="C#">
        /// visitor.AddError(new TextLocation(1, 1), "ErrorText", "ErrorMessage", "script.txt");
        /// </code>
        /// </example>
        void AddError(TextLocation? start, string txt, string message, string path)
        {
            if (start == null)
                start = TextLocation.Empty;
            _diagnostics.AddError(start.InDocument(path ?? Filename ?? string.Empty), txt, message);
        }

        /// <summary>
        /// Adds an error to the diagnostics container.
        /// </summary>
        /// <param name="start">The location of the error. Must not be null.</param>
        /// <param name="txt">The text associated with the error. Must not be null.</param>
        /// <param name="message">The error message. Must not be null.</param>
        /// <remarks>
        /// This method adds an error to the diagnostics container with the specified location, text, and message.
        /// </remarks>
        /// <example>
        /// <code lang="C#">
        /// visitor.AddError(new TextLocation(1, 1), "ErrorText", "ErrorMessage");
        /// </code>
        /// </example>
        void AddError(TextLocation start, string txt, string message)
        {
            _diagnostics.AddError(start.InDocument(Filename ?? string.Empty), txt, message);
        }

        /// <summary>
        /// Adds a warning to the diagnostics container.
        /// </summary>
        /// <param name="start">The location of the warning. Must not be null.</param>
        /// <param name="txt">The text associated with the warning. Must not be null.</param>
        /// <param name="message">The warning message. Must not be null.</param>
        /// <remarks>
        /// This method adds a warning to the diagnostics container with the specified location, text, and message.
        /// </remarks>
        /// <example>
        /// <code lang="C#">
        /// visitor.AddWarning(new TextLocation(1, 1), "WarningText", "WarningMessage");
        /// </code>
        /// </example>
        void AddWarning(TextLocation start, string txt, string message)
        {
            _diagnostics.AddWarning(start.InDocument(Filename ?? string.Empty), txt, message);
        }

        /// <summary>
        /// Adds a warning to the diagnostics container.
        /// </summary>
        /// <param name="start">The location of the warning. Must not be null.</param>
        /// <param name="txt">The text associated with the warning. Must not be null.</param>
        /// <param name="message">The warning message. Must not be null.</param>
        /// <param name="path">The file path of the script. Can be null or empty.</param>
        /// <remarks>
        /// This method adds a warning to the diagnostics container with the specified location, text, message, and path.
        /// </remarks>
        /// <example>
        /// <code lang="C#">
        /// visitor.AddWarning(new TextLocation(1, 1), "WarningText", "WarningMessage", "script.txt");
        /// </code>
        /// </example>
        void AddWarning(TextLocation start, string txt, string message, string path)
        {
            _diagnostics.AddWarning(start.InDocument(path ?? Filename ?? string.Empty), txt, message);
        }

        /// <summary>
        /// Adds an error to the diagnostics container from a parser rule context.
        /// </summary>
        /// <param name="r">The parser rule context containing the error. Must not be null.</param>
        /// <remarks>
        /// This method adds an error to the diagnostics container based on the information in the parser rule context.
        /// </remarks>
        /// <example>
        /// <code lang="C#">
        /// var context = parser.rule();
        /// visitor.AddError(context);
        /// </code>
        /// </example>
        void AddError(ParserRuleContext r)
        {

            int stateId = r.invokingState;

            if (stateId == -1)
                stateId = r.exception.OffendingState;

            ATNState state = _parser.Atn.states[stateId];
            string o0 = _parser.RuleNames[state.ruleIndex];
            string o1 = _parser.RuleNames[r.RuleIndex];

            _diagnostics.AddError(r.Start.ToLocation(Filename ?? string.Empty), r.Start.Text, $"Failed to parse script. '{o0}' expect '{o1}'");

        }

        /// <summary>
        /// Adds an error to the diagnostics container from an error node.
        /// </summary>
        /// <param name="e">The error node containing the error. Must not be null.</param>
        /// <remarks>
        /// This method adds an error to the diagnostics container based on the information in the error node.
        /// </remarks>
        /// <example>
        /// <code lang="C#">
        /// var errorNode = parser.errorNode();
        /// visitor.AddError(errorNode);
        /// </code>
        /// </example>
        void AddError(ErrorNodeImpl e)
        {
            _diagnostics.AddError(e.Symbol.ToLocation(Filename ?? string.Empty), e.Symbol.Text,
                    $"Failed to parse script at position {e.Symbol.StartIndex}, line {e.Symbol.Line}, col {e.Symbol.Column} '{e.Symbol.Text}'"
            );
        }




        #region Context

        /// <summary>
        /// Gets the current build context from the top of the context stack.
        /// </summary>
        /// <remarks>
        /// This property provides access to the current build context, which contains
        /// information needed for code generation such as parameters, expressions, and source code.
        /// </remarks>
        /// <returns>
        /// The current <see cref="BuildContext"/> from the top of the stack.
        /// </returns>
        protected BuildContext BuildCtx
        {
            get => _stack.Peek();
        }

        /// <summary>
        /// Gets or sets the path of the script being processed.
        /// </summary>
        /// <remarks>
        /// This property stores the file path of the script being compiled,
        /// which is useful for diagnostics and source reference.
        /// </remarks>
        /// <example>
        /// <code lang="C#">
        /// var builder = new Sourcebuilder(diagnostics, true);
        /// builder.ScriptPath = @"C:\Policies\access_policy.txt";
        /// </code>
        /// </example>
        public string ScriptPath { get; internal set; }

        /// <summary>
        /// Creates a new build context based on the current context and pushes it onto the context stack.
        /// </summary>
        /// <remarks>
        /// This method creates a new context that inherits properties from the current context,
        /// pushes it onto the stack, and returns a disposable wrapper that will pop the context
        /// when disposed.
        /// </remarks>
        /// <exception cref="System.InvalidOperationException">Thrown when the context stack is empty.</exception>
        /// <returns>
        /// A <see cref="CurrentContext"/> object that will restore the previous context when disposed.
        /// </returns>
        protected BuildContext NewContext()
        {
            var ctx = _stack.Count > 0 ? _stack.Peek() : null;
            Action act = () => _stack.Pop();
            var cts = new BuildContext(act) { Parent = ctx };
            _stack.Push(cts);
            return cts;
        }

        /// <summary>
        /// Gets the current build context from the top of the context stack.
        /// </summary>
        /// <remarks>
        /// This method provides access to the current build context without creating a new one.
        /// </remarks>
        /// <exception cref="System.InvalidOperationException">Thrown when the context stack is empty.</exception>
        /// <returns>
        /// The current <see cref="BuildContext"/> from the top of the stack.
        /// </returns>
        protected BuildContext CurrentCtx()
        {
            var ctx = _stack.Peek();
            return ctx;
        }




        ///// <summary>
        ///// Provides a disposable wrapper for a build context.
        ///// </summary>
        ///// <remarks>
        ///// This class automatically restores the previous build context when disposed,
        ///// making it easy to use build contexts in a scope-based manner.
        ///// </remarks>
        //protected class CurrentContext : IDisposable
        //{
        //    /// <summary>
        //    /// Initializes a new instance of the <see cref="CurrentContext"/> class.
        //    /// </summary>
        //    /// <param name="act">The action to execute when this context is disposed. Must not be null.</param>
        //    /// <param name="current">The current build context. Must not be null.</param>
        //    /// <remarks>
        //    /// This constructor creates a new context wrapper with the specified cleanup action.
        //    /// </remarks>
        //    public CurrentContext(Action act, BuildContext current)
        //    {
        //        action = act;
        //        Current = current;
        //    }

        //    /// <summary>
        //    /// Disposes of the context and restores the previous context.
        //    /// </summary>
        //    /// <remarks>
        //    /// This method executes the cleanup action specified in the constructor,
        //    /// which typically pops the context from the stack.
        //    /// </remarks>
        //    public void Dispose()
        //    {
        //        action();
        //    }

        //    /// <summary>
        //    /// The action to execute when this context is disposed.
        //    /// </summary>
        //    /// <remarks>
        //    /// This action typically pops the current build context from the stack.
        //    /// </remarks>
        //    private Action action;

        //    /// <summary>
        //    /// Gets the build context wrapped by this instance.
        //    /// </summary>
        //    /// <remarks>
        //    /// This property provides access to the current build context.
        //    /// </remarks>
        //    public BuildContext Current { get; }
        //    public bool InoperationBoolean { get; internal set; }

        //}

        /// <summary>
        /// Stack of build contexts used for tracking the current compilation state.
        /// </summary>
        /// <remarks>
        /// This stack maintains a hierarchical structure of build contexts,
        /// allowing for nested processing of expressions and statements.
        /// </remarks>
        protected Stack<BuildContext> _stack = new Stack<BuildContext>();

        /// <summary>
        /// Represents a context for code generation during policy compilation.
        /// </summary>
        /// <remarks>
        /// BuildContext contains information needed for code generation such as parameters,
        /// expressions, and source code, as well as a dictionary for storing temporary values.
        /// </remarks>
        protected class BuildContext : IDisposable
        {
            /// <summary>
            /// Initializes a new instance of the <see cref="BuildContext"/> class.
            /// </summary>
            /// <remarks>
            /// This constructor initializes a new build context with an empty storage dictionary.
            /// </remarks>
            public BuildContext(Action action)
            {
                this._action = action;
                _dic = new Dictionary<string, object>();
            }

            /// <summary>
            /// Adds a value to the context's storage dictionary.
            /// </summary>
            /// <param name="key">The key to store the value under. Must not be null.</param>
            /// <param name="value">The value to store.</param>
            /// <remarks>
            /// This method stores a value in the context's dictionary under the specified key.
            /// If a value already exists for the key, it is replaced.
            /// </remarks>
            /// <exception cref="System.ArgumentNullException">Thrown when key is null.</exception>
            public void AddInStorage(string key, object value)
            {
                _dic[key] = value;
            }

            /// <summary>
            /// Tries to get a value from the context's storage dictionary.
            /// </summary>
            /// <param name="key">The key to look up. Must not be null.</param>
            /// <param name="value">When this method returns, contains the value associated with the key, if found.</param>
            /// <returns>True if the key was found; otherwise, false.</returns>
            /// <remarks>
            /// This method attempts to retrieve a value from the context's dictionary using the specified key.
            /// </remarks>
            /// <exception cref="System.ArgumentNullException">Thrown when key is null.</exception>
            public bool TryGetInStorage<T>(string key, out T value)
            {

                value = default;
                if (_dic.TryGetValue(key, out var v))
                {
                    value = (T)v;
                    return true;
                }

                return false;

            }

            public void Dispose()
            {
                this._action();
            }

            private readonly Action _action;

            /// <summary>
            /// Dictionary for storing temporary values in the build context.
            /// </summary>
            /// <remarks>
            /// This dictionary stores values that need to be accessible within the current build context.
            /// </remarks>
            private Dictionary<string, object> _dic;

            public BuildContext? Parent { get; internal set; }

        }

        /// <summary>
        /// Specifies the kind of code being generated.
        /// </summary>
        /// <remarks>
        /// This enumeration indicates whether the code being generated is for a constructor, method, or undefined.
        /// </remarks>
        protected enum KindGenerating
        {
            /// <summary>
            /// The kind of code being generated is not specified.
            /// </summary>
            Undefined,

            /// <summary>
            /// The code being generated is for a constructor.
            /// </summary>
            Constructor,

            /// <summary>
            /// The code being generated is for a method.
            /// </summary>
            Method,
        }

        #endregion Context

        /// <summary>
        /// The initial source text of the policy being parsed.
        /// </summary>
        /// <remarks>
        /// This field stores the original source text for reference and error reporting.
        /// </remarks>
        private StringBuilder? _initialSource;

        /// <summary>
        /// The policy parser that generated the parse tree.
        /// </summary>
        /// <remarks>
        /// This field stores a reference to the parser for accessing token information and parse context.
        /// </remarks>
        private readonly PolicyParser _parser;

        /// <summary>
        /// Container for diagnostic messages generated during parsing.
        /// </summary>
        /// <remarks>
        /// This field stores errors, warnings, and informational messages that occur during parsing.
        /// </remarks>
        private ScriptDiagnostics _diagnostics;

        /// <summary>
        /// The file path of the policy script being parsed.
        /// </summary>
        /// <remarks>
        /// This field stores the full path to the script file for error reporting and diagnostics.
        /// </remarks>
        private readonly string _scriptPath;

        /// <summary>
        /// The container to which parsed policies are added.
        /// </summary>
        /// <remarks>
        /// This field stores the container that will hold all the parsed policy variables and rules.
        /// </remarks>
        private PolicyContainer? _container;

        /// <summary>
        /// Action to execute on each parsed policy rule.
        /// </summary>
        /// <remarks>
        /// This field stores a callback that is invoked for each successfully parsed policy rule.
        /// </remarks>
        private readonly Action<PolicyRule>? _action;

        /// <summary>
        /// The directory containing the policy script being parsed.
        /// </summary>
        /// <remarks>
        /// This field stores the directory path, which is used for resolving relative imports.
        /// </remarks>
        public readonly string ScriptPathDirectory;

        /// <summary>
        /// The culture used for parsing culture-specific values.
        /// </summary>
        /// <remarks>
        /// This field stores the culture settings used for parsing numbers, dates, and other culture-specific values.
        /// </remarks>
        private CultureInfo _currentCulture;

    }

}


